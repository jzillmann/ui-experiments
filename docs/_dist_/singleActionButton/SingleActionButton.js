/* src/singleActionButton/SingleActionButton.svelte generated by Svelte v3.29.7 */
import {
	SvelteComponent,
	append,
	attr,
	create_component,
	destroy_component,
	detach,
	element,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	set_data,
	space,
	text,
	transition_in,
	transition_out
} from "../../web_modules/svelte/internal.js";

import Experiment from "../shared/Experiment.js";
import Button from "./Button.js";
import EitherOr from "./EitherOr.js";
import { refresh, save } from "../svg/svgs.js";

function create_description_slot(ctx) {
	let div0;

	return {
		c() {
			div0 = element("div");

			div0.innerHTML = `<div class="font-bold">Challenge:</div> 
        <div class="flex justify-center"><ul class="list-disc list-inside text-left max-w-2xl"><li>Implement a <i>click - fetch - done</i> button pattern + a button turning into another one.</li> 
                <li>Get that visually somewhat right.</li> 
                <li>Experiment with it structurally:
                    <ul class="ml-4 list-disc list-inside"><li>What styles are best - in terms of re-usability - defined inside the button, which outside ?</li> 
                        <li>How to couple the logic ? Use a promise, a Svelte store, something different ?</li></ul></li></ul></div>`;

			attr(div0, "slot", "description");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
		},
		d(detaching) {
			if (detaching) detach(div0);
		}
	};
}

// (64:20) <span slot="either">
function create_either_slot_1(ctx) {
	let span;
	let button;
	let current;

	button = new Button({
			props: {
				name: "Refresh",
				svgSpec: { ...refresh, size: 5 },
				pressed: /*pressed*/ ctx[0],
				extraClass: "bg-teal-600"
			}
		});

	button.$on("click", /*handleClick*/ ctx[2]);

	return {
		c() {
			span = element("span");
			create_component(button.$$.fragment);
			attr(span, "slot", "either");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			mount_component(button, span, null);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*pressed*/ 1) button_changes.pressed = /*pressed*/ ctx[0];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			destroy_component(button);
		}
	};
}

// (72:20) <span slot="or">
function create_or_slot_1(ctx) {
	let span;
	let button;
	let current;

	button = new Button({
			props: {
				name: "Save",
				svgSpec: { ...save, size: 5 },
				pressed: /*pressed*/ ctx[0],
				extraClass: "bg-green-600"
			}
		});

	button.$on("click", /*handleClick*/ ctx[2]);

	return {
		c() {
			span = element("span");
			create_component(button.$$.fragment);
			attr(span, "slot", "or");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			mount_component(button, span, null);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*pressed*/ 1) button_changes.pressed = /*pressed*/ ctx[0];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			destroy_component(button);
		}
	};
}

// (63:16) <EitherOr either={!changed}>
function create_default_slot_2(ctx) {
	let t;
	let current;

	return {
		c() {
			t = space();
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (88:20) <span slot="either">
function create_either_slot(ctx) {
	let span;
	let button;
	let current;

	button = new Button({
			props: {
				name: "Refresh",
				svgSpec: { ...refresh, size: 5 },
				pressed: /*pressed*/ ctx[0],
				extraClass: "bg-teal-600"
			}
		});

	button.$on("click", /*handleClick*/ ctx[2]);

	return {
		c() {
			span = element("span");
			create_component(button.$$.fragment);
			attr(span, "slot", "either");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			mount_component(button, span, null);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*pressed*/ 1) button_changes.pressed = /*pressed*/ ctx[0];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			destroy_component(button);
		}
	};
}

// (96:20) <span slot="or">
function create_or_slot(ctx) {
	let span;
	let button;
	let current;

	button = new Button({
			props: {
				name: "Save",
				svgSpec: { ...save, size: 5 },
				pressed: /*pressed*/ ctx[0],
				extraClass: "bg-green-600"
			}
		});

	button.$on("click", /*handleClick*/ ctx[2]);

	return {
		c() {
			span = element("span");
			create_component(button.$$.fragment);
			attr(span, "slot", "or");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			mount_component(button, span, null);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*pressed*/ 1) button_changes.pressed = /*pressed*/ ctx[0];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			destroy_component(button);
		}
	};
}

// (87:16) <EitherOr either={!changed}>
function create_default_slot_1(ctx) {
	let t;
	let current;

	return {
		c() {
			t = space();
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (36:4) <div slot="content">
function create_content_slot(ctx) {
	let div0;
	let div13;
	let div4;
	let div1;
	let t1;
	let button0;
	let t2;
	let button1;
	let t3;
	let div2;
	let button2;
	let t4;
	let button3;
	let t5;
	let div3;
	let button4;
	let t6;
	let button5;
	let t7;
	let div8;
	let div5;
	let t9;
	let eitheror0;
	let t10;
	let div6;
	let t11;
	let t12;
	let t13;
	let div7;
	let t14;
	let t15;
	let t16;
	let div12;
	let div9;
	let t18;
	let eitheror1;
	let t19;
	let div10;
	let t20;
	let t21;
	let t22;
	let div11;
	let t23;
	let t24;
	let current;

	button0 = new Button({
			props: {
				name: "UnPressed",
				svgSpec: refresh,
				pressed: false,
				extraClass: "bg-yellow-600"
			}
		});

	button1 = new Button({
			props: {
				name: "Pressed",
				svgSpec: refresh,
				pressed: true,
				extraClass: "bg-yellow-600"
			}
		});

	button2 = new Button({
			props: {
				name: "UnPressed",
				svgSpec: { ...refresh, size: 5 },
				pressed: false,
				extraClass: "bg-yellow-600"
			}
		});

	button3 = new Button({
			props: {
				name: "Pressed",
				svgSpec: { ...refresh, size: 5 },
				pressed: true,
				extraClass: "bg-yellow-600"
			}
		});

	button4 = new Button({
			props: {
				name: "UnPressed",
				svgSpec: { ...save, size: 5 },
				pressed: false,
				extraClass: "bg-blue-600"
			}
		});

	button5 = new Button({
			props: {
				name: "Pressed",
				svgSpec: { ...save, size: 5 },
				pressed: true,
				extraClass: "bg-blue-600"
			}
		});

	eitheror0 = new EitherOr({
			props: {
				either: !/*changed*/ ctx[1],
				$$slots: {
					default: [create_default_slot_2],
					or: [create_or_slot_1],
					either: [create_either_slot_1]
				},
				$$scope: { ctx }
			}
		});

	eitheror1 = new EitherOr({
			props: {
				either: !/*changed*/ ctx[1],
				$$slots: {
					default: [create_default_slot_1],
					or: [create_or_slot],
					either: [create_either_slot]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div0 = element("div");
			div13 = element("div");
			div4 = element("div");
			div1 = element("div");
			div1.textContent = "Static";
			t1 = space();
			create_component(button0.$$.fragment);
			t2 = space();
			create_component(button1.$$.fragment);
			t3 = space();
			div2 = element("div");
			create_component(button2.$$.fragment);
			t4 = space();
			create_component(button3.$$.fragment);
			t5 = space();
			div3 = element("div");
			create_component(button4.$$.fragment);
			t6 = space();
			create_component(button5.$$.fragment);
			t7 = space();
			div8 = element("div");
			div5 = element("div");
			div5.textContent = "Dynamic";
			t9 = space();
			create_component(eitheror0.$$.fragment);
			t10 = space();
			div6 = element("div");
			t11 = text("Pressed: ");
			t12 = text(/*pressed*/ ctx[0]);
			t13 = space();
			div7 = element("div");
			t14 = text("Changed: ");
			t15 = text(/*changed*/ ctx[1]);
			t16 = space();
			div12 = element("div");
			div9 = element("div");
			div9.textContent = "Simulation";
			t18 = space();
			create_component(eitheror1.$$.fragment);
			t19 = space();
			div10 = element("div");
			t20 = text("Pressed: ");
			t21 = text(/*pressed*/ ctx[0]);
			t22 = space();
			div11 = element("div");
			t23 = text("Changed: ");
			t24 = text(/*changed*/ ctx[1]);
			attr(div1, "class", "font-bold mb-3");
			attr(div2, "class", "mt-4 text-sm tracking-tighter");
			attr(div3, "class", "mt-4 text-sm tracking-tighter");
			attr(div5, "class", "font-bold mb-3");
			attr(div6, "class", "mt-2");
			attr(div7, "class", "mt-2");
			attr(div9, "class", "font-bold mb-2");
			attr(div10, "class", "mt-2");
			attr(div11, "class", "mt-2");
			attr(div13, "class", "flex justify-around space-x-4");
			attr(div0, "slot", "content");
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			append(div0, div13);
			append(div13, div4);
			append(div4, div1);
			append(div4, t1);
			mount_component(button0, div4, null);
			append(div4, t2);
			mount_component(button1, div4, null);
			append(div4, t3);
			append(div4, div2);
			mount_component(button2, div2, null);
			append(div2, t4);
			mount_component(button3, div2, null);
			append(div4, t5);
			append(div4, div3);
			mount_component(button4, div3, null);
			append(div3, t6);
			mount_component(button5, div3, null);
			append(div13, t7);
			append(div13, div8);
			append(div8, div5);
			append(div8, t9);
			mount_component(eitheror0, div8, null);
			append(div8, t10);
			append(div8, div6);
			append(div6, t11);
			append(div6, t12);
			append(div8, t13);
			append(div8, div7);
			append(div7, t14);
			append(div7, t15);
			append(div13, t16);
			append(div13, div12);
			append(div12, div9);
			append(div12, t18);
			mount_component(eitheror1, div12, null);
			append(div12, t19);
			append(div12, div10);
			append(div10, t20);
			append(div10, t21);
			append(div12, t22);
			append(div12, div11);
			append(div11, t23);
			append(div11, t24);
			current = true;
		},
		p(ctx, dirty) {
			const eitheror0_changes = {};
			if (dirty & /*changed*/ 2) eitheror0_changes.either = !/*changed*/ ctx[1];

			if (dirty & /*$$scope, pressed*/ 9) {
				eitheror0_changes.$$scope = { dirty, ctx };
			}

			eitheror0.$set(eitheror0_changes);
			if (!current || dirty & /*pressed*/ 1) set_data(t12, /*pressed*/ ctx[0]);
			if (!current || dirty & /*changed*/ 2) set_data(t15, /*changed*/ ctx[1]);
			const eitheror1_changes = {};
			if (dirty & /*changed*/ 2) eitheror1_changes.either = !/*changed*/ ctx[1];

			if (dirty & /*$$scope, pressed*/ 9) {
				eitheror1_changes.$$scope = { dirty, ctx };
			}

			eitheror1.$set(eitheror1_changes);
			if (!current || dirty & /*pressed*/ 1) set_data(t21, /*pressed*/ ctx[0]);
			if (!current || dirty & /*changed*/ 2) set_data(t24, /*changed*/ ctx[1]);
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(button2.$$.fragment, local);
			transition_in(button3.$$.fragment, local);
			transition_in(button4.$$.fragment, local);
			transition_in(button5.$$.fragment, local);
			transition_in(eitheror0.$$.fragment, local);
			transition_in(eitheror1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(button2.$$.fragment, local);
			transition_out(button3.$$.fragment, local);
			transition_out(button4.$$.fragment, local);
			transition_out(button5.$$.fragment, local);
			transition_out(eitheror0.$$.fragment, local);
			transition_out(eitheror1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			destroy_component(button0);
			destroy_component(button1);
			destroy_component(button2);
			destroy_component(button3);
			destroy_component(button4);
			destroy_component(button5);
			destroy_component(eitheror0);
			destroy_component(eitheror1);
		}
	};
}

// (16:0) <Experiment title="Single Action Button">
function create_default_slot(ctx) {
	let t;
	let current;

	return {
		c() {
			t = space();
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment(ctx) {
	let experiment;
	let current;

	experiment = new Experiment({
			props: {
				title: "Single Action Button",
				$$slots: {
					default: [create_default_slot],
					content: [create_content_slot],
					description: [create_description_slot]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(experiment.$$.fragment);
		},
		m(target, anchor) {
			mount_component(experiment, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const experiment_changes = {};

			if (dirty & /*$$scope, changed, pressed*/ 11) {
				experiment_changes.$$scope = { dirty, ctx };
			}

			experiment.$set(experiment_changes);
		},
		i(local) {
			if (current) return;
			transition_in(experiment.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(experiment.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(experiment, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let pressed = false;
	let changed = false;

	function handleClick() {
		$$invalidate(0, pressed = true);

		new Promise(r => setTimeout(r, 900)).then(() => {
			$$invalidate(0, pressed = false);
			$$invalidate(1, changed = !changed);
		});
	}

	return [pressed, changed, handleClick];
}

class SingleActionButton extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default SingleActionButton;